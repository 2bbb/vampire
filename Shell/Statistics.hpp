/**
 * @file Statistics.hpp
 * Defines proof-search statistics
 *
 * @since 02/01/2008 Manchester
 */

#ifndef __Statistics__
#define __Statistics__

#include <ostream>

#include "Forwards.hpp"

#include "Lib/RCPtr.hpp"
#include "Lib/ScopedPtr.hpp"

//#include "Kernel/Assignment.hpp"
//#include "Kernel/Constraint.hpp"

extern const char* VERSION_STRING;

namespace Kernel {
  class Unit;
}

namespace Shell {

using namespace std;
using namespace Kernel;
using namespace Solving;

/**
 * Class Statistics
 * @since 02/01/2008 Manchester
 */
class Statistics
{
public:
  Statistics();

  void print(ostream& out);

  // Input
  /** number of input clauses */
  unsigned inputClauses;
  /** number of input formulas */
  unsigned inputFormulas;

  // Preprocessing
  /** number of formula names introduced during preprocessing */
  unsigned formulaNames;
  /** number of initial clauses */
  unsigned initialClauses;
  /** number of inequality splittings performed */
  unsigned splitInequalities;
  /** number of formulas with propagated variable equalities */
  unsigned propagatedEqualities;
  /** number of formulas with removed variables which occurred only once and that was in equality */
  unsigned removedSingletonVariables;
  /** number of pure predicates */
  unsigned purePredicates;
  /** number of trivial predicates */
  unsigned trivialPredicates;
  /** predicates reversed in order to make problem Horn */
  unsigned hornReversedPredicates;
  /** number of definitions transformed by EPR preserving skolemization*/
  unsigned eprPreservingSkolemizations;
  /** number of inlined predicate definitions */
  unsigned inlinedPredicateDefinitions;
  /** number of merged predicate definitions */
  unsigned mergedPredicateDefinitions;
  /** number of unused predicate definitions */
  unsigned unusedPredicateDefinitions;
  /** number of eliminated function definitions */
  unsigned functionDefinitions;
  /** number of formulas selected by SInE selector */
  unsigned selectedBySine;
  /** number of iterations before SInE reached fixpoint */
  unsigned sineIterations;

  //Generating inferences
  /** number of clauses generated by factoring*/
  unsigned factoring;
  /** number of clauses generated by binary resolution*/
  unsigned resolution;
  /** number of clauses generated by unit resulting resolution*/
  unsigned urResolution;
  /** number of clauses generated by forward superposition*/
  unsigned forwardSuperposition;
  /** number of clauses generated by backward superposition*/
  unsigned backwardSuperposition;
  /** number of clauses generated by self superposition*/
  unsigned selfSuperposition;
  /** number of clauses generated by equality factoring*/
  unsigned equalityFactoring;
  /** number of clauses generated by equality resolution*/
  unsigned equalityResolution;

  // Simplifying inferences
  /** number of duplicate literals deleted */
  unsigned duplicateLiterals;
  /** number of literals s |= s deleted */
  unsigned trivialInequalities;
  /** number of forward subsumption resolutions */
  unsigned forwardSubsumptionResolution;
  /** number of backward subsumption resolutions */
  unsigned backwardSubsumptionResolution;
  /** number of forward demodulations */
  unsigned forwardDemodulations;
  /** number of forward demodulations into equational tautologies */
  unsigned forwardDemodulationsToEqTaut;
  /** number of backward demodulations */
  unsigned backwardDemodulations;
  /** number of backward demodulations into equational tautologies */
  unsigned backwardDemodulationsToEqTaut;
  /** number of forward literal rewrites */
  unsigned forwardLiteralRewrites;
  /** number of condensations */
  unsigned condensations;
  /** number of global subsumptions */
  unsigned globalSubsumption;
  /** number of evaluations */
  unsigned evaluations;
  /** number of interpreted simplifications */
  unsigned interpretedSimplifications;

  // Deletion inferences
  /** number of tautologies A \/ ~A */
  unsigned simpleTautologies;
  /** number of equational tautologies s=s */
  unsigned equationalTautologies;
  /** number of forward subsumed clauses */
  unsigned forwardSubsumed;
  /** number of backward subsumed clauses */
  unsigned backwardSubsumed;
  /** number of empty clause subsumptions by BDD marking*/
  unsigned subsumedByMarking;

  // Saturation
  /** all clauses ever occurring in the unprocessed queue */
  unsigned generatedClauses;
  /** all passive clauses */
  unsigned passiveClauses;
  /** all active clauses */
  unsigned activeClauses;

  unsigned discardedNonRedundantClauses;

  unsigned inferencesSkippedDueToColors;

  /** passive clauses at the end of the saturation algorithm run */
  unsigned finalPassiveClauses;
  /** active clauses at the end of the saturation algorithm run */
  unsigned finalActiveClauses;

  /** number of clause reactivations */
  unsigned reactivatedClauses;

  unsigned splitClauses;
  unsigned splitComponents;
  unsigned uniqueComponents;
  /** Number of introduced name predicates for splitting without backtracking */
  unsigned splittingNamesIntroduced;
  /** Derived clauses with empty non-propositional and non-empty propositional part */
  unsigned bddPropClauses;
  /** Number of clauses generated for the SAT solver */
  unsigned satClauses;
  /** Number of unit clauses generated for the SAT solver */
  unsigned unitSatClauses;
  /** Number of binary clauses generated for the SAT solver */
  unsigned binarySatClauses;
  /** Number of clauses learned by the SAT solver */
  unsigned learntSatClauses;
  /** Number of literals in clauses learned by the SAT solver */
  unsigned learntSatLiterals;
  /** Memory used by BDDs */
  size_t bddMemoryUsage;

  unsigned backtrackingSplits;
  unsigned backtrackingSplitsRefuted;
  unsigned backtrackingSplitsRefutedZeroLevel;

  unsigned satSplits;
  unsigned satSplitRefutations;

  unsigned instGenGeneratedClauses;
  unsigned instGenRedundantClauses;
  unsigned instGenKeptClauses;
  unsigned instGenIterations;

  unsigned maxBFNTModelSize;

  /** Number of pure variables eliminated by SAT solver */
  unsigned satPureVarsEliminated;

#if GNUMP
  /**
   * added for the purpose of Bound porpagation
   * @since 25.10.2012 Vienna
   * @author Ioan Dragan
   */
  
  // Input
  /** number of input constraints */
  unsigned inputConstraints;
  /** number of input variables */
  unsigned inputVariables;
  /** number of constraints after preprocessing */
  unsigned preprocessedConstraints;
  /** number of variables after preprocessing */
  unsigned preprocessedVariables;

  // Preprocessing
  /** number of variables that were equivalent to some other
   * variable and were eliminated */
  unsigned equivalentVariables;
  /** number of variables eliminated by equality propagation */
  unsigned equalityPropagationVariables;
  /** number of constraints affected by equality propagation */
  unsigned equalityPropagationConstraints;
  /** number of eliminated constant variables */
  unsigned constantVariables;
  /** number of constraints updated by constant propagation */
  unsigned updatedByConstantPropagation;
  /** number of subsumed constraints */
  unsigned subsumedConstraints;
  /** number of variables appearing either only positively or only
   * negatively */
  unsigned halfBoundingVariables;
  /** number of constraints deleted due to half-bounding variables */
  unsigned halfBoundingConstraints;
  /** number of variables appearing either only positively or only
   * negatively except for one constraint */
  unsigned almostHalfBoundingVariables;
  /** number of constraints removed or replaced due to almost half-bounding variables */
  unsigned almostHalfBoundingConstraints;
  /** number of variables that were eliminated by Fourier-Motzkin because the
   * elimination introduced allowed amount of clauses */
  unsigned fmRemovedVariables;
  /** number of constraints introduced by Fourier-Motzkin variable elimination
   * in preprocessing */
  unsigned preprocessingFMIntroduced;
  /** number of constraints removed by Fourier-Motzkin variable elimination
   * in preprocessing */
  unsigned preprocessingFMRemoved;

  // Solving
  /** number of decision points where the variable was picked by heuristics */
  unsigned freeDecisionPoints;
  /** number of decision points where the variable was predetermined */
  unsigned forcedDecisionPoints;
  /** maximal number of decision points at a moment*/
  DecisionLevel maxDecisionDepth;
  /** number of backtracks */
  unsigned backtracks;
  /** number of backtracks by more than one decision level */
  unsigned longBacktracks;
  /** number of propagated bounds */
  unsigned propagatedBounds;
  /** number of generated conflict clauses */
  unsigned conflictClauses;
  /** how many times the conservative assigment selector reused previous assignment */
  unsigned assignmentsReusedByConservative;
  /** number of selected conflict that were not the most recent conflicts available */
  unsigned nonRecentConflicts;
  /** number of collapsing clauses that we retained for bound propagation */
  unsigned retainedConstraints;

  //Number representation
  /** True if native numbers were used during computation */
  bool nativeUsed;
  /** True if precise numbers were used during computation */
  bool preciseUsed;
  /** Time (in ms) when we switched from native to precise numbers */
  unsigned switchToPreciseTimeInMs;

  /** refutation if @c terminationReason==REFUTATION */
  ConstraintRCPtr bpRefutation;
  /** satisfying assignment if @c terminationReason==SATISFIABLE */
  ScopedPtr<Assignment> satisfyingAssigment;

#endif //GNUMP
  
  /** termination reason */
  enum TerminationReason {
    /** refutation found */
    REFUTATION,
    /** satisfiability detected (saturated set built) */
    SATISFIABLE,
    /** saturation terminated but an incomplete strategy was used */
    REFUTATION_NOT_FOUND,
    /** unknown termination reason */
    UNKNOWN,
    /** time limit reached */
    TIME_LIMIT,
    /** memory limit reached */
    MEMORY_LIMIT
  };
  /** termination reason */
  TerminationReason terminationReason;
  /** refutation, if any */
  Kernel::Unit* refutation;
  /** the saturated set of clauses, if any */
  Kernel::UnitList* saturatedSet;
  /** if problem is satisfiable and we obtained a model, contains its
   * representation; otherwise it is an empty string */
  string model;

  enum ExecutionPhase {
    /** Whatever happens before we start parsing the problem */
    INITIALIZATION,
    PARSING,
    /** Scanning for properties to be passed to preprocessing */
    PROPERTY_SCANNING,
    NORMALIZATION,
    SINE_SELECTION,
    INCLUDING_THEORY_AXIOMS,
    PREPROCESS_1,
    EQUALITY_PROPAGATION,
    PREDIACTE_DEFINITION_MERGING,
    EPR_PRESERVING_SKOLEMIZATION,
    PREDICATE_DEFINITION_INLINING,
    UNUSED_PREDICATE_DEFINITION_REMOVAL,
    PREPROCESS_2,
    NAMING,
    PREPROCESS_3,
    CLAUSIFICATION,
    FUNCTION_DEFINITION_ELIMINATION,
    INEQUALITY_SPLITTING,
    EQUALITY_RESOLUTION_WITH_DELETION,
    EQUALITY_PROXY,
    GENERAL_SPLITTING,
    HORN_REVEALING,
    /** The actual run of the saturation algorithm */
    SATURATION,
    /** The actual run of the conflict resolution algorithm */
    SOLVING,
    /** The actual run of the SAT solver*/
    SAT_SOLVING,
    PREPROCESSING,
    /** Whatever happens after the saturation algorithm finishes */
    FINALIZATION,
    UNKNOWN_PHASE
  };

  ExecutionPhase phase;

private:
  static void addCommentIfCASC(ostream&); 
  static const char* phaseToString(ExecutionPhase p);
}; // class Statistics

}

#endif
